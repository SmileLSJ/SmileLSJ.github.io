---
layout:     post
title:      "Netty-13-实现一个RPC框架2"
date:       2021-09-22 12:00:00
author:     "LSJ"
header-img: "img/post-bg-2015.jpg"
tags:
    - 拉钩
    - Netty
    - 拉钩Netty
---



Netty的经典实用：蚂蚁的SoFABolt 

网址：https://github.com/sofastack/sofa-bolt



## 通讯机制

* 主要工作
  * 服务消费者实现协议编码，向服务提供者发送调用数据
  * 服务提供者收到数据后解码，然后向服务消费者发送响应数据，暂时忽略RPC请求是如何被调用的
  * 服务消费者收到响应数据后成功返回。

### RPC通用方案设计

* RPC请求调用过程

  ![Drawing 0.png](../../img/Cip5yF_1MaqAfz8pAAYSNNmMolY852.png)

  * 数据发送前，服务消费者将 RPC 请求信息封装成 MiniRpcProtocol 对象，然后通过编码器 MiniRpcEncoder 进行二进制编码，最后直接向发送至远端即可。
  * 服务提供者收到请求数据后，将二进制数据交给解码器 MiniRpcDecoder，解码后再次生成 MiniRpcProtocol 对象，然后传递给 RpcRequestHandler 执行真正的 RPC 请求调用。

* RPC调用返回过程

  ![Drawing 1.png](../../img/CgqCHl_1MbKAZCUWAAX6xAhFw5k042.png)

  * 与 RPC 请求过程相反，是由服务提供者将响应结果封装成 MiniRpcProtocol 对象，然后通过 MiniRpcEncoder 编码发送给服务消费者
  * 服务消费者对响应结果进行解码，因为 RPC 请求是高并发的，所以需要 RpcRequestHandler 根据响应结果找到对应的请求，最后将响应结果返回

* 最终的服务消费者和服务提供者的ChannelPipeline结构

  ![Drawing 2.png](../../img/CgqCHl_1MbmAeZgjAAd9EAWpmuE609.png)



### 自定义RPC通信协议

* 协议是服务消费者和服务提供者之间通信的基础，主流的 RPC 框架都会自定义通信协议，相比于 HTTP、HTTPS、JSON 等通用的协议，自定义协议可以实现更好的性能、扩展性以及安全性

* 简版的RPC自定义协议

  ```txt
  +---------------------------------------------------------------+
  | 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |
  +---------------------------------------------------------------+
  | 状态 1byte |        消息 ID 8byte     |      数据长度 4byte     |
  +---------------------------------------------------------------+
  |                   数据内容 （长度不定）                          |
  +---------------------------------------------------------------+
  ```

  * 协议分为
    * 协议头Header
    * 协议体Body
  * 协议头包括
    * 魔数
    * 协议版本号
    * 序列化算法
    * 报文类型
    * 状态
    * 消息ID
    * 消息长度
  * 协议体Body只包含
    * 数据内容部分，数据内容的长度是不固定的

  * 对应的协议实体类

    ```java
    @Data
    public class MiniRpcProtocol<T> implements Serializable {
        private MsgHeader header; // 协议头
        private T body; // 协议体
    }
    @Data
    public class MsgHeader implements Serializable {
        private short magic; // 魔数
        private byte version; // 协议版本号
        private byte serialization; // 序列化算法
        private byte msgType; // 报文类型
        private byte status; // 状态
        private long requestId; // 消息 ID
        private int msgLen; // 数据长度
    }
    ```

  * 在RPC场景中，MiniRpcProtocol中泛型的T对应的MiniRpcRequest类型，主要包含RPC远程调用需要的必须参数

    ```java
    @Data
    public class MiniRpcRequest implements Serializable {
        private String serviceVersion; // 服务版本
        private String className; // 服务接口名
        private String methodName; // 服务方法名
        private Object[] params; // 方法参数列表
        private Class<?>[] parameterTypes; // 方法参数类型列表
    }
    ```

* RPC通信的返回 MiniRpcResponse

  ```java
  ```

  



