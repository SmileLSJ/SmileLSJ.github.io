---
layout:     post
title:      "消息队列学习--基础"
date:       2021-10-18 12:00:00
author:     "LSJ"
header-img: "img/post-bg-2015.jpg"
tags:
    - 消息队列
---



## 适用场景

1. 异步处理

   1. 好处
      1. 可以更快返回结果
      2. 减少等待，自然实现了步骤之间的并发，提升系统总体的性能

2. 流量控制

   1. 使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的。

      1. 流程变成

         ![img](../../../img/7909fb792a059e22a0a269c1f2cde64a.jpg)

         1. 网关在接收到请求后，将请求放入请求消息队列
         2. 后端服务从请求消息队列中获取APP请求，完成后续秒杀处理过程，然后返回结果

      2. 问题

         1. 增加了系统调用链环节，导致总体的响应时间延迟变长
         2. 上下游系统都要将同步调用改成异步消息，增加了系统的复杂度

   2. 优化方案：如果能预估出秒杀服务的处理能力，就可以用消息队列实现一个令牌桶，更简单地进行流量控制。

      1. 令牌桶控制流量的原理是：单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前**必须先从令牌桶中拿出一个令牌**，**如果令牌桶中没有令牌，则拒绝请求**。这样就保证单位时间内，能处理的请求不超过发放令牌的数量，起到了流量控制的作用。

         ![img](../../../img/2c4e42056b78fff7746de28245910f89.jpg)

      2. 令牌桶可以简单地用一个有固定容量的消息队列加一个“令牌发生器”来实现：令牌发生器按照预估的处理能力，匀速生产令牌并放入令牌队列（如果队列满了则丢弃令牌），网关在收到请求时去令牌队列消费一个令牌，获取到令牌则继续调用后端秒杀服务，如果获取不到令牌则直接返回秒杀失败。

3. 服务解耦

4. 引入消息队列同样的也会出现下面问题：

   1. 引入消息队列带来的延迟问题
   2. 增加了系统的复杂度
   3. 可能产生<font color='red'>数据不一致问题</font>





## MQ选型

1. rabbitmq：
   1. 优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置
   2. 缺点：性能和吞吐量较差，不易进行二次开发
2. rocketmq：
   1. 优点：性能好，稳定可靠，有活跃的中文社区，特点响应快
   2. 缺点：兼容性较差，但随意影响力的扩大，该问题会有改善
3. kafka：
   1. 优点：拥有强大的性能及吞吐量，兼容性很好
   2. 缺点：由于“攒一波再处理”导致延迟比较高
4. pulsar：
   1. 采用存储和计算分离的设计，是消息队里产品中黑马，值得持续关注
5. 其中RocketMQ怎么做到低延迟？？？
   1. 主要是设计上的选择问题，Kafka中到处都是“批量和异步”设计，它更关注的是整体的吞吐量，而RocketMQ的设计选择更多的是尽量及时处理请求。
   2. 比如发消息，同样是用户调用了send()方法，RockMQ它会直接把这个消息发出去，而Kafka会把这个消息放到本地缓存里面，然后择机异步批量发送。
   3. 所以，RocketMQ它的时延更小一些，而Kafka的吞吐量更高。